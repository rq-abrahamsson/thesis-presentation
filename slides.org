#+TITLE: Comparing modifiability of React Native and two native codebases
#+AUTHOR: By: Robin Abrahamsson and David Berntsen
#+EMAIL: robab960@student.liu.se davbe067@student.liu.se
#+DATE: Examiner: Ola Leifler, Supervisor: Lena Buffoni

#+REVEAL_ROOT: file:///Users/robin.abrahamsson/reveal.js-master/


#+REVEAL_THEME: black
#+REVEAL_TRANS: default
#+REVEAL_DEFAULT_FRAG_STYLE: current-visible

#+REVEAL_POSTAMBLE: <p> Created by Robin Abrahamsson and David Berntsen. </p>
#+REVEAL_PLUGINS: (markdown notes math)
#+REVEAL_EXTRA_CSS: ./custom-stylesheet.css

#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:nil reveal_control:nil
#+OPTIONS: reveal_rolling_links:t reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1200 reveal_height:800
#+OPTIONS: toc:1
#+OPTIONS: reveal_title_slide:"<h2>%t</h2><p>%a</p><p>%d</p>"


* Background
#+BEGIN_NOTES
 * 2 billion smartphones
 * Android significant worldwide
 * Entire market -> applications on all platforms
.
 * Duplicate code, especially
 * Difference in syntax, test suites, packages. Sharing of code not really possible
.  
 * From that we started to look for a way to evaluate if migrating is 
 a good decision, to help this decision we looked at modifiability
 * Working hypothesis, improve
 * Additional factors, have impact. API changes. OS, components, framework language.
#+END_NOTES
** Research questions
   #+ATTR_REVEAL: :frag (t)
  * Is modifiability a quality attribute that can be calculated to assist in the choice of two implementation solutions for mobile applications?
  * How can information about releases of the platforms be quantified to understand the possible impact on modifiability?
   #+BEGIN_NOTES
   Based on the hypothesis the following research questions were produced:
   * Is modifiability a quality attribute that can be calculated to assist in the choice of two implementation solutions for mobile applications?
   * How can information about releases of the platforms be quantified to understand the possible impact on modifiability?
   #+END_NOTES
* Concepts
** Mobile applications
   #+ATTR_REVEAL: :frag (t)
 * Native applications
 * Web applications
 * Hybrid applications
   #+BEGIN_NOTES
 * There are essentially three different kinds of mobile applications; native, web and hybrid applications.
 * NATIVE, specific platform. 
 * Access to device specific.
 * Platform specific language
 * iOS in Objective-c or Swift, Android Java
.
 * WEB, HTML, CSS, JavaScript. Web browser.
 * Lack acces to low level features. graphics, offline.
. 
 * HYBRID, installed like native
 * HTML, CSS, JavaScript, native container WebView.
 * Access device specific.
   #+END_NOTES
** React Native
   #+BEGIN_NOTES
     * Open source by Facebook.
     * March 2015
     * JavaScript
     * To native components and therefore resulting applications are native.
   #+END_NOTES
** SQMMA
   (Software Quality Model for Maintainability Analysis)
   #+ATTR_REVEAL: :frag (t)
 * Analysability
 * Modifiability
 * Testability
 * Modularity
 * Reusability
   #+BEGIN_NOTES
   * The Software Quality Model for Maintainability Analysis (SQMMA) quantifies 
   quality attributes to achieve a value for maintainability. 
   These quality attributes are:
   .
   * Quality attributes quantified by certain metrics.
   * Metrics are then weighted depending on the impoct of that quality attribute.
   * Modifiability was chosen for this thesi.
   #+END_NOTES
** Modifiability
   #+ATTR_REVEAL: :frag (t)
 * avgSize
 * Communication
 * Coupling
 * EntExt
 * Hierarchies
 * LCohesion
 * MethodInheri
 * Nesting
 * Polymorph
 * Subclasses
   #+BEGIN_NOTES
   * The following metrics was used to quantify modifiability:
   #+END_NOTES
* Our work
** Data from release cycles
   #+BEGIN_NOTES
   * Different release cycles, time effort
   * Change a function call, to deprecate and kill functionality
   * Data about releases were gathered for iOS, Android and React Native.
   #+END_NOTES
** The applications
   #+BEGIN_NOTES
   * First question, two applications Valtech.
   * General functionality
   * what graphical components, 6 -> Navbar, Menu, List view
   .
   After deciding which components should be migrated, 
   the files that were related to the components were 
   then located in both the iOS and Android codebases. 
   With the help of these files, the functionality of 
   every component was identified and as much functionality 
   as possible was then migrated to the React Native applications. 
   #+END_NOTES
   #+REVEAL: split
   #+CAPTION:
   #+NAME: fig:menu
   #+ATTR_HTML: :height 500
   [[./images/full-application.png]]

   #+REVEAL: split
   #+CAPTION:
   #+NAME: fig:menu
   #+ATTR_HTML: :height 500
   [[./images/menu.png]]

** Static analyzers
#+BEGIN_NOTES
 * After the migration was done we performed static analyzis to extract metrics
 * Exist tools, none open source with reliable results
 * Usually out dated or covered other metrics.
 * Decided to create analyzers
 * Python, regexp
 * Give you an understanding of how the analyzers work, code snippets.
#+END_NOTES
#+REVEAL: split
#+BEGIN_SRC python
effCoupling = 0
with open(file_name, 'r') as f:
    s = f.read()
    matches = re.findall('import.*\.\/.*\;',s)
    effCoupling = len(matches)

import_regexp = "import.*" + class_name + "\'*\;"
try:
    affCoupling = len(sh.grep("-r",
                              import_regexp, 
                              "src", 
                              "index.android.js", 
                              "index.ios.js")
                        .splitlines())
except:
    affCoupling = 0
coupling = affCoupling + effCoupling
#+END_SRC
#+BEGIN_NOTES
The first code snippet shows how the coupling value for React Native is extracted.
Efferent coupling counts the number of imports in the file. Afferent coupling 
counts the number of times the current class is imported in the rest of the codebase.
#+END_NOTES

#+REVEAL: split
#+BEGIN_SRC python
nrMethods = 0
methods = []
with open(file_path, 'r') as f:
    s = f.read()
    regex_matches = re.findall('[-+] \(.*',s)
    for match in regex_matches:
        methods.append(match[match.find(')')+1:match.find(':')])
    nrMethods = len(methods)
#+END_SRC
#+BEGIN_NOTES
This second code snippet shows the how the number of methods in a class is counted 
in the iOS codebase.
#+END_NOTES
* Results & Discussion
** Platform stability
*** Additions
|---+---------------+--------------+---------+------|
|   | Additions per | React Native | Android |  iOS |
|---+---------------+--------------+---------+------|
| / | >             |            < |         |      |
|   | Day           |         1.61 |       5 |   16 |
|   | Release       |         26.6 |     898 | 1877 |
|---+---------------+--------------+---------+------|
*** Removals 
|---+--------------+--------------+---------+-----|
|   | Removals per | React Native | Android | iOS |
|---+--------------+--------------+---------+-----|
| / | >            |            < |         |     |
|   | Day          |         0.13 |    0.25 |   1 |
|   | Release      |          2.2 |      45 | 109 |
|---+--------------+--------------+---------+-----|



** Modifiability
   
   #+REVEAL: split
   #+ATTR_HTML: :height 500
   [[./images/application-modifiability-sum.png]]


# * Summary
#   #+ATTR_REVEAL: :frag (t)
#   * Existing Android and iOS applications
#   * Developed React Native application
#   * SQMMA
#   * Static Analyzers
#   * Modifiability over time
# ** Research Questions
#    #+ATTR_REVEAL: :frag (t)
#    * Is modifiability a quality attribute that can be calculated to assist in the choice of two implementation solutions for mobile applications?
#    * How can information about releases of the platforms be quantified to understand the possible impact on modifiability?

* Conclusion
  #+ATTR_REVEAL: :frag (t)
  * Platform stability
  * More data needed
  * Modifiability
* Future work
  #+ATTR_REVEAL: :frag (t)
  * Extend current codebase
  * Static analyzers
  * Metric evaluation

* Thanks for listening!
